
import heapq

class Node:
    def __init__(self, level, value, weight, bound):
        self.level = level
        self.value = value
        self.weight = weight
        self.bound = bound

    def __lt__(self, other):
        return self.bound > other.bound  # for max heap

def bound(node, n, capacity, weights, values):
    if node.weight >= capacity:
        return 0
    profit_bound = node.value
    j = node.level + 1
    total_weight = node.weight

    while j < n and total_weight + weights[j] <= capacity:
        total_weight += weights[j]
        profit_bound += values[j]
        j += 1

    if j < n:
        profit_bound += (capacity - total_weight) * (values[j] / weights[j])

    return profit_bound

def knapsack_branch_and_bound(weights, values, capacity):
    n = len(values)
    # Sort items by value-to-weight ratio
    index = sorted(range(n), key=lambda i: values[i] / weights[i], reverse=True)
    weights = [weights[i] for i in index]
    values = [values[i] for i in index]

    max_value = 0
    queue = []

    v = Node(-1, 0, 0, 0)
    v.bound = bound(v, n, capacity, weights, values)
    heapq.heappush(queue, v)

    while queue:
        v = heapq.heappop(queue)

        if v.level == n - 1:
            continue

        u = Node(v.level + 1, v.value, v.weight, 0)

        # Check taking the current item
        u.weight = v.weight + weights[u.level]
        u.value = v.value + values[u.level]

        if u.weight <= capacity and u.value > max_value:
            max_value = u.value

        u.bound = bound(u, n, capacity, weights, values)

        if u.bound > max_value:
            heapq.heappush(queue, u)

        # Check without taking the current item
        u.weight = v.weight
        u.value = v.value
        u.bound = bound(u, n, capacity, weights, values)

        if u.bound > max_value:
            heapq.heappush(queue, u)

    return max_value

# Example usage
n = int(input("Enter number of items: "))
weights = list(map(int, input(f"Enter the weights of {n} items: ").split()))
values = list(map(int, input(f"Enter the values of {n} items: ").split()))
capacity = int(input("Enter the capacity of the knapsack: "))

result_bb = knapsack_branch_and_bound(weights, values, capacity)
print(f"Maximum value using Branch and Bound: {result_bb}")
